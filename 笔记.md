# xwjs.md

# 参考资料

  - ## yayu大神的github

    https://github.com/mqyqingfeng/Blog/issues/22

  - ## Vue2.x参考点

    https://www.cnblogs.com/queenya/p/13572754.html

  - ## 常见问题

    https://blog.csdn.net/weixin_42724176/article/details/104955474


# 前端小百科

  - ## html渲染过程


  - ## css垂直水平居中

  - ## 介绍下重绘和回流（Repaint & Reflow），以及如何进行优化 

    **个人理解：**

    重绘：例如color的改变并不影响节点，造成页面的渲染

    回流（重排）：页面节点发生变化，或者影响布局的样式发生变化，而造成的渲染

    回流必然伴随重绘甚至伴随大量回流，重绘不一定回流

    解决：
     1.从操作上来讲，虚拟dom + diff算法的出现已经极大减少了回流重绘。
     2.css方面的样式，详见百度
     3.js方面

     https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/24

  - ## 进程与线程

    比如，打开谷歌浏览器就是一个进程，浏览器渲染页面会用到gui线程，js线程
    进程是系统分配调度的单位，线程是cpu执行的单位

  - ## cookie、localStorage和sessionStorage的区别

    共同点：都是保存在浏览器端、且同源的

    cookie优点：

    可以控制有效期，没有设置有效期为会话cookie，当浏览器关闭，清除cookie

    使用cookie做本地存储的3个缺点

    1：存储太小，最大4KB

    2：随http请求一起被发送到服务端，增加了请求数据量

    3：document.cookie这个API过于简陋，存在安全隐患

    使用localStorage和sessionStorage做本地存储的3个优点

    1：存储容量大，最大5M

    2：不会随http请求一起被发送到服务端，减少了请求数据量

    3：提供更简单易用的API，setItem和getItem

    localStorage和sessionStorage的区别

    localStorage：永久存储数据，除非代码或手动删除

    sessionStorage：临时存储数据，浏览器关闭后自动清除
  
  - ## xss和csrf概念及区别，如何防止

    CSRF（Cross-site request forgery）：跨站请求伪造

    访问恶意网站对已登录的网站发送请求，模拟用户操作

    防止： 
    1.token验证
    2.Referer验证，不同源的网站直接禁止（憨憨操作）

    XSS（Cross Site Scripting）：跨域脚本攻击

    通过地址栏、输入框向页面注入脚本代码

    防止：
    1.字符编码
    2.script标签序列化

    区别一：

    CSRF：需要用户先登录网站A，获取 cookie。XSS：不需要登录。

    区别二：（原理的区别）

    CSRF：是利用网站A本身的漏洞，去请求网站A的api。XSS：是向网站 A 注入 JS代码，然后执行 JS 里的代码，篡改网站A的内容。

  - ## 浏览器的事件循环，任务队列


# vue2.x小小百科

  - ## vue组件中为什么data是一个函数

    确保每个组件在被调用的时候都维护属于自己的data，防止数据冲突
  - ## Vue生命周期

    beforeCreate（创建前）: 在数据观测和初始化事件还未开始,data、watcher、methods都还不存在，但是$route已存在，可以根据路由信息进行重定向等操作。

    created(创建后)：在实例创建之后被调用，该阶段可以访问data，使用watcher、events、methods，也就是说 数据观测(data observer) 和event/watcher 事件配置 已完成。但是此时dom还没有被挂载。该阶段允许执行http请求操作。

    beforeMount （挂载前）：将HTML解析生成AST节点，再根据AST节点动态生成渲染函数。相关render函数首次被调用(划重点)。

    mounted (挂载后)：在挂载完成之后被调用，执行render函数生成虚拟dom，创建真实dom替换虚拟dom，并挂载到实例。可以操作dom，比如事件监听

    beforeUpdate：vm.data更新之后，虚拟dom重新渲染之前被调用。在这个钩子可以修改vm.data更新之后，虚拟dom重新渲染之前被调用。在这个钩子可以修改vm.data更新之后，虚拟dom重新渲染之前被调用。在这个钩子可以修改vm.data，并不会触发附加的冲渲染过程。

    updated：虚拟dom重新渲染后调用，若再次修改$vm.data，会再次触发beforeUpdate、updated，进入死循环。

    beforeDestroy：实例被销毁前调用，也就是说在这个阶段还是可以调用实例的。

    destroyed：实例被销毁后调用，所有的事件监听器已被移除，子实例被销毁

  - ## mvvm的理解

    请看mvvm目录

    view ---- vm ---- model

    视图的改变影响数据，数据改变影响视图

  - ## 双向绑定原理
  
    <elInput v-model="inputData"/> 相当于 <elInput :inputValue="inputData" @setValue="val => inputData=val"/>

    <!-- child -->
    model: {
      prop: 'inputValue',
      event: 'setValue'
    },
    event默认是input,子组件可以通过modal自定义emit事件名

    当看完mvvm的解析，就很清楚了
    v-model是v-bind和v-on的结合，bind绑定元素(prop1)添加watcher，当数据改变通过事件回调修改prop1的值
  - ## 虚拟dom，diff算法

  - ## element-ui的组件通信

    请查看文件 jsApi/element-event.js

    用来解决未知层级的父子组件通信

    例如：

    root - a1  - aa1
               - aa2
        .- b1  - bb1  - bbb1

    我想让 a1,b1,aa1,bb1,.....与root通信

    - dispatch
      
      子传祖： 子组件派发(dispatch)事件-->祖先组件监听($on)事件

    - broadcast与dispatch相反

# 学习别人造的轮子
  
  - ## webpack基础

    https://github.com/ironZn/xwts

  - ## webpack中hash,chunkhash,contenthash的区别

    hash: 每次wepack构建时会生成一个唯一的hash值。
      问题: 因为js和css同时使用一个hash值。
      如果重新打包，会导致所有缓存失效。（可能我却只改动一个文件）

    chunkhash：根据chunk生成的hash值。如果打包来源于同一个chunk，那么hash值就一样
      问题: js和css的hash值还是一样的
      因为css是在js中被引入的，所以同属于一个chunk

    contenthash: 根据文件的内容生成hash值。不同文件hash值一定不一样    
      --> 让代码上线运行缓存更好使用

  - ## webpack打包优化

    - dev优化：

      - 打包

        1. HMR：热模块替换。只更新有改动的模块。

      - 运行

        1. source-map       

        2. 预加载：webpackPrefetch，等其它资源加载完毕，再加载。
          import(/* webpackChunkName: 'test', webpackPrefetch: true */'./test').then();

    - prod优化：

      打包：

        1. 按需加载，babel的预设useBuiltIns：'usage'

        2. 打包缓存,babel的cacheDirectory：true

        3. 多进程打包，使用thread-loader。

        4. externals，对于三方依赖，react，jquery...的cdn,拒绝将它们打包

        5. dll，配置哪些库不参与打包


      运行：

        1. entry多入口，使用多个bundle减少单个文件代码体积

        2. optimization.splitChunk，将node_modules单独打包成一个chunk

        3. tree-shaking（树摇），剔除无用代码，sideEffects:["*.css", "*.less"]

        4. pwa，离线可访问


  - ## webpack插件开发

    参考链接：https://blog.csdn.net/qq_36380426/article/details/104471422

    - 插件可执行的生命周期 compiler.hooks.xxx
      1. entryOption：在 webpack 选项中的 entry 配置项 处理过之后，执行插件
      2. afterPlugins：设置完初始插件之后，执行插件
      3. compilation： 编译创建之后，生成文件之前，执行插件
      4. emit：生成资源到 output 目录之前
      5. done：编译完成
  
    - 应急策略（没写过咋整？）
      插件的原型上要有个apply方法提供给webpack挂载，apply的回调（compiler）就是你的插件将要在webpack中执行的入口。
      compiler可以调用不同类型的钩子，同步，异步，promise，这可以根据你自己的需要来。
      然后调用不同的执行周期，把你写的插件逻辑放到对应的周期下执行。
      定义构造函数用来接收插件传递的参数。

      详情参考链接。

# js api实现的实现

  - ## 实现一个Promise

   完整版实现很绕（我直接躺平），我这里实现一个低配的promise

   请查看文件 jsApi/promise.js

  - ## 实现节流防抖函数

  - ## 实现call apply bind函数

  - ## 实现new

# 深入浅出nodejs

  - ## 使用http创建一个简单的服务

    请查看文件 in-out-nodejs/baseServer.js

  - ## 实现一个简单版的express

    请查看目录 in-out-nodejs/miniExpress

  - ## SSR是啥

    ssr指游戏中超超稀有的神卡。。。。

    是一项前端优化的策略

    https://zhuanlan.zhihu.com/p/93199714

    ![avatar](/res/ssr.jpeg)

    **个人理解：**

    服务端渲染：

      - 通过一个node服务对浏览器和后台架设一个中间层。
      - 页面接口请求和代码组装都交给node服务完成，极大减少浏览器的压力。
      - 所以页面首次展示的时候就已经完整了，有利于seo

    渲染流程：

      1. 页面首次加载时，给node服务发送一个url（路由），node服务将http请求转发至后台获取首屏数据。
      2. node服务根据后端返回的数据和页面路由匹配对应组件进行解析合并
      3. 将解析的最终结果返回给页面

  - ## 什么是BFF

    BFF —— Backend For Frontend（服务于前端的后端）

    **个人理解：**

    主要作用是给后台接口加个中间层，实现服务聚合（接口合并），多端应用（pc, app）。

    同时，可以有效的进行访问控制（调用权限），应用缓存（接口数据缓存），第三方交互（交互放在 BFF 层，防止泄露隐私）。

    是有点大前端小中台的意思。


  - ## eggjs的理解

    https://zhuanlan.zhihu.com/p/311444574

    ![avatar](/res/mvc.jpeg)

    Egg 中的 MVC

    - Middleware、Router、Controller 分别负责请求的包装、分发、业务处理，都是纯逻辑，属于广义的 C；
    - Service 提供数据服务，其实已经是 M，这个数据可能来自更底层的 Model，也可能依赖外部服务；
    - Model 一般指直接连接数据库的行为。

    **总结**

    - 基于 koa 比 express 更优秀的异步洋葱模型、context 结构，egg 选择了 koa
    - egg 在 koa 之上，对 app、context 做扩展，提供了基于扩展、插件的渐进式开发能力
    - egg 奉行「约定优于配置」，对 MVC 设计中的各个部分做了目录约定
    - 对于应用部署、日志、HttpClient、Cookie and Session / 鉴权、数据库 / ORM、定时任务等常见场景，egg 也通过各种插件提供开箱即用的能力



 

  

  
  